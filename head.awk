#DO NOT EDIT THIS FILE
(NR == 1) {
	ismodule = 1
	docdir = "Doc/"
	plaindocfile = substr(FILENAME,1,length(FILENAME)-1) "doc"
	docfile = docdir plaindocfile
	docoffset = 0
	started = 0
	wantlinenum = 0
	fname = FILENAME
	codefname = "C" substr(fname,1,length(fname)-1) "h.tmp"
	DFNfname = "DFN" substr(fname,1,length(fname)-1) "h.tmp"
	DCLfname = "DCL" substr(fname,1,length(fname)-1) "h.tmp"
	fname = ""
	FS = ":"
	typeline = ""
	nameline = ""
	synopsisline = ""
	docline = ""
	seeline = ""
	exampleline = ""
	valueline = ""
	printf "/************************************/\n" > codefname
	printf "/* Initialization code from %s */\n", FILENAME > codefname
	printf "/************************************/\n\n\n" > codefname
	printf "/* Declarations to be included in every "> DCLfname
	printf "source file */\n/* Created from %s*/\n\n", FILENAME > DCLfname
	printf "/* Definitions to be included in init.c */\n"> DFNfname
	printf "/* Created from %s */\n\n", FILENAME > DFNfname
}
/awkstart/ {	started = 1
		name = ""
		lispname = ""
		minargs = -2
		maxargs = -2
		type = ""
		synopsis = ""
		doc = ""
		doclen = 0
		see = ""
		example = ""
		key = ""
		keyname = ""
 }

######################################################################
#			   N A M E
######################################################################

(started == 1) && ($1 ~ /Name/) {
	name = $2
	while ( substr(name,1,1) == " " ) name = substr(name,2,length(name))

	matchplace = match(name,"_lisp$")
	if (matchplace == 0)
		matchplace = length(name)
	else matchplace = matchplace - 1
	lispname = substr(name,1,matchplace)
	prevdocline = ""
}

######################################################################
#			  K E Y
######################################################################

(started == 1) && ($1 ~ /Key/) { key = $2
	while ( substr(key,1,1) == " " ) key = substr(key,2)
	if ((key == "") && (NF==3)) key = ":"
	if (key == "&") keyname="and_"
	if (key == ":") keyname="colon_"
	if (key == "+") keyname="plus_"
	if (key == "*") keyname="star_"
	if (key == "!") keyname="bang_"
	if (key == "$") keyname="dollar_"
}

######################################################################
#			  A R G S
######################################################################

(started == 1) && ($1 ~ /MinArgs/) { minargs = $2 }
(started == 1) && ($1 ~ /MaxArgs/) { maxargs = $2 }
(started == 1) && ($1 ~ /Type/) {
	type = $2;
	while ( substr(type,1,1) == " " ) type = substr(type,2,length(type))
#	tmpdoc = sprintf("Name: %s\t\t\t\t\t\t%s\n\n", key name, type)
#	printf "%s", tmpdoc > docfile
#	doclen += length(tmpdoc)
}

######################################################################
#			S Y N O P S I S
######################################################################

(started == 1) && ($1 ~ /Synopsis/) {
	len1 = length($1)
	gsub(/[^\\]</,"<$t insert end {&} $curtag>")
	synopsis = substr($0,len1+2)
	tmpdoc = sprintf("<set curtag red>Synopsis:<set curtag reg>\n%s\n\n<set curtag red>Description:<set curtag reg>\n", synopsis)
	printf "%s", tmpdoc > docfile
	doclen += length(tmpdoc)
}

######################################################################
#			   D O C
######################################################################

(started == 1) && ($1 ~ /Doc/) {
	len1 = length($1)
	if (doc=="")
	{
		doc = substr($0,len1+2)
	}
	gsub(/[^\\]</,"<$t insert end {&} $curtag>")
	tmpdoc = sprintf("%s\n", substr($0,len1+2))
	printf "%s", tmpdoc > docfile
	doclen += length(tmpdoc)
}

######################################################################
#			S E E    A L S O
######################################################################

(started == 1) && ($1 ~ /SEE/) {
	len1 = length($1)
	gsub(/[^\\]</,"<$t insert end {&} $curtag>")
	if (see == "")
	{
		see = substr($0,len1+2)
		tmpdoc = sprintf("%s", "\n\n<set curtag red>SEE ALSO:\n\t<set curtag See>")
		printf "%s", tmpdoc > docfile
		doclen += length(tmpdoc)
	}
	tmpdoc = sprintf("%s\n", substr($0,len1+2))
	printf "%s", tmpdoc > docfile
	doclen += length(tmpdoc)
}

######################################################################
#			  E X A M P L E
######################################################################

(started == 1) && ($1 ~ /Example/) {
	len1 = length($1)
	gsub(/[^\\]</,"<$t insert end {&} $curtag>")
	if (example=="")
	{
		example = substr($0,len1+2)
		tmpdoc = sprintf("%s","<set curtag red>\n\nExamples:<set curtag reg>\n")
		printf "%s", tmpdoc > docfile
		doclen += length(tmpdoc)
			# Examples go to the end of docfile.
	}
	tmpdoc = sprintf("%s\n", substr($0,len1+2))
	printf "%s", tmpdoc > docfile
	doclen += length(tmpdoc)
}

######################################################################
#			P R O C E S S I N G
######################################################################

/awkstop/  { started = 0
	docoffset += doclen
#
# Create the <codefname> to be included in the init routines
#
	printf "\n/**********\t%s\t**********/\n", name > codefname
	printf "\tinstall_C_functions(\"%s\",", key lispname > codefname
	printf "&S%s,", keyname name > codefname
	printf "%s,\n", keyname name > codefname
	printf "\t\t%d,%d,", minargs, maxargs> codefname
	printf "C_2_L_%s,", type > codefname
	printf "\n\t\t\"%s\",\n\t\t", doc > codefname
	printf "\"%s\",", plaindocfile > codefname
	printf "%d,", docoffset-doclen > codefname
	printf "%d,", doclen > codefname
	printf "%d,", NR > codefname
	printf "\n\t\t\"%s\");\n", FILENAME > codefname
# Update new_funcs if it is a module. Variable new_funcs is used to
# determine which functions to kill when the module is unloaded.
	if (ismodule==1)
	{
	  printf "new_funcs = cons(" > codefname
	  printf "symbol_function(S%s),new_funcs);\n", keyname name > codefname
	}
#
# Create the <DCLfname> with the procedure headers, to be included everywhere.
#
	printf "extern L_Ptr %s();\n", keyname name > DCLfname
	printf "extern L_Ptr S%s;\n",  keyname name > DCLfname
#
# Create the <DFNfname> for the DEFINITIONS of related structures.
# Definitions are included only once in the init.c
#
	printf "L_Ptr S%s;\n", keyname name > DFNfname

}

######################################################################
######################################################################
#
#		V A R I A B L E S
#
######################################################################
######################################################################


/awkvarstart/ {
	startvar = 1
	name = ""
	value = ""
	doc = ""
	key = ""
	keyname = ""
}

######################################################################
#		N A M E  (var)
######################################################################

(startvar == 1) && ($1 ~ /Name/) { 
	name = $2
	while ( substr(name,1,1) == " " ) name = substr(name,2,length(name))
	doclen = 0
	prevdocline = ""
}

######################################################################
#		V A L U E  (var)
######################################################################

(startvar == 1) && ($1 ~ /Value/) {
			value = $2
}

######################################################################
#		K E Y    (var)
######################################################################

(startvar == 1) && ($1 ~ /Key/) { key = $2
	while ( substr(key,1,1) == " " ) key = substr(key,2)
	if ((key == "") && (NF==3)) key = ":"
	if (key == "&") keyname="and_"
	if (key == ":") keyname="colon_"
	if (key == "+") keyname="plus_"
	if (key == "*") keyname="star_"
	if (key == "!") keyname="bang_"
	if (key == "$") keyname="dollar_"
}

######################################################################
#		D O C   (var)
######################################################################

(startvar == 1) && ($1 ~ /Doc/) {
	len1 = length($1)
	if (doc=="")
	{
		doc = substr($0,len1+2)
		tmpdoc = sprintf("%s\n", "<set curtag red>Description:\n<set curtag reg>");
		printf "%s", tmpdoc > docfile
		doclen += length(tmpdoc)
	}
	gsub(/[^\\]</,"<$t insert end {&} $curtag>")
	tmpdoc = sprintf("%s\n", substr($0,len1+2))
	printf "%s", tmpdoc > docfile
	doclen += length(tmpdoc)
}

######################################################################
#	P R O C E S S I G
######################################################################

/awkvarstop/ {
	startvar = 0
	docoffset += doclen
	while ( substr(name,1,1) == " " ) name = substr(name,2)
	while ( substr(value,1,1) == " " ) value = substr(value,2)
#
# Create the <codefname> to be included in the init routines
#
	printf "\n/**********\t%s\t**********/\n", name > codefname
	printf "\tinstall_C_vars(\"%s\",", key name > codefname
	printf "&S%s,", keyname name > codefname
#       The value is never set in the parameter list, because it might
#       involve things defined inside install_C_vars
#	if ( value != "" )
#	{
#		printf "\n\t\t%s=%s,\n", keyname name, value > codefname
#	} else
	{
		printf "%s,\n", "NULL" > codefname
	}
	printf "\n\t\t\"%s\",\n\t\t", doc > codefname
	printf "\"%s\",", plaindocfile > codefname
	printf "%d,", docoffset-doclen > codefname
	printf "%d,", doclen > codefname
	printf "%d,", NR > codefname
	printf "\n\t\t\"%s\");\n", FILENAME > codefname
	if ( value != "" )
	{
		printf "\n\t\t%s=%s;\n", keyname name, value > codefname
#		printf "set(S%s,%s);\n", keyname name, value > codefname
		printf "\t\tset(S%s,%s);\n", keyname name, keyname name > codefname
	}

#
# Create the <DCLfname> with the procedure headers, to be included everywhere.
#
	printf "%s", nameline > DCLfname
	printf "extern L_Ptr S%s;\n", keyname name > DCLfname
	if ( value != "" )
		printf "extern L_Ptr %s;\n", keyname name > DCLfname
#
# Create the <DFNfname> for the DEFINITIONS of related structures.
# Definitions are included only once in the init.c
#
	printf "%s", nameline > DFNfname
	printf "L_Ptr S%s;\n", keyname name > DFNfname
	if ( value != "" )
		printf "L_Ptr %s;\n", keyname name > DFNfname

}
######################################################################
######################################################################
#
#	I M P O R T
#
######################################################################
######################################################################

/awkimportstart/ {
	startimport = 1
	module = ""
}

/awkimportstop/ {
	startimport = 0
}

######################################################################
#	F U N C T I O N
######################################################################

(startimport == 1) && ($1 ~ /Function/) {
	name = $2
	while ( substr(name,1,1) == " " ) name = substr(name,2)
		matchplace = match(name,"_lisp$")
	if (matchplace == 0)
		matchplace = length(name)
	else matchplace = matchplace - 1
	lispname = substr(name,1,matchplace)
#
# Put initialisng code in <codefname>
#
	printf "\tS%s = intern(C_2_L_string(", name > codefname
	printf "\"%s\"),NIL);\n", lispname > codefname
	printf "\tawktemp = symbol_function(S%s);\n", name > codefname
	printf "\tif (! (FUNCTIONP(awktemp)||VFUNCTIONP(awktemp)||SPECIALFRMP(awktemp)||\n" > codefname
	printf "\t       VSPECIALFRMP(awktemp)||MACROP(awktemp)||VMACROP(awktemp)))\n" > codefname
	printf "\t  %s = zombie;\n", name > codefname
	printf "\telse %s=XFUNCTION(awktemp);\n", name > codefname
#
# Put decalrations in <DCLfname>
#
	printf "extern L_Ptr S%s;\n", name > DCLfname
	printf "extern L_Ptr (*%s)();\n", name > DCLfname
#
# Put definitions in <DFNfname>
#
	printf "L_Ptr S%s;\n", name > DFNfname
	printf "L_Ptr (*%s)();\n", name > DFNfname
}

######################################################################
#	S Y M B O L
######################################################################

(startimport == 1) && ($1 ~ /Symbol/) {
	name = $2
	while ( substr(name,1,1) == " " ) name = substr(name,2)
#
# Put initialisng code in <codefname>
#
	printf "\tS%s=intern(C_2_L_string(\"%s\"),NIL);\n",name,name>codefname
#
# Put decalrations in <DCLfname>
#
	printf "extern L_Ptr S%s;\n", name > DCLfname
#
# Put definitions in <DFNfname>
#
	printf "L_Ptr S%s;\n", name > DFNfname
}


######################################################################
#	M O D U L E
######################################################################

(startimport == 1) && ($1 ~ /Module/) {
	name = $2
        while ( substr(name,1,1) == " " ) name = substr(name,2)
#
# Put initialisng code in <codefname>
#
        printf "\tif (NULLP(runningp(C_2_L_string(" >codefname
	printf "\"%s\"))))\n", name >codefname
	printf "\t\tdlopen_lisp(C_2_L_string(" >codefname
	printf "\"%s\"));\n", name >codefname
}

